<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SJ1471PPQX"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decentrifi - Smart Contract Gas Analytics</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary-blue: #346DF1;
            --accent-teal: #22D1C6;
            --gradient: linear-gradient(45deg, #346DF1, #7D4CFF);
            --light-bg: #F5F8FA;
            --dark-text: #2A2E3D;
            --border-color: #E1E4E8;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--dark-text);
            line-height: 1.5;
            background-color: var(--light-bg);
            opacity: 0;
            animation: pageLoadFade 0.8s ease forwards;
        }

        /* Grid & Layout */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 16px;
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            margin: 0 -16px;
        }

        .col-12 { width: 100%; }
        .col-4 { width: 33.33%; }
        .col-6 { width: 50%; }

        @media (max-width: 768px) {
            .col-4, .col-6 { width: 100%; }
        }

        /* Typography */
        h1 {
            font-size: 48px;
            line-height: 1.2;
            background: var(--gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
            margin-bottom: 24px;
            letter-spacing: -0.5px;
        }

        h2 {
            font-size: 32px;
            line-height: 40px;
            color: var(--dark-text);
            font-weight: 600;
            margin-bottom: 16px;
        }

        p {
            font-size: 16px;
            line-height: 24px;
            color: rgba(42, 46, 61, 0.8);
        }

        /* Header & Navigation */
        .header {
            padding: 16px 0;
            position: fixed;
            width: 100%;
            z-index: 100;
            transition: background-color 0.3s ease;
            background-color: transparent;
            opacity: 0;
            transform: translateY(-20px);
            animation: headerLoadIn 0.6s ease forwards 0.2s;
        }

        .header.scrolled {
            background-color: #ffffff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .logo-lockup {
            display: flex;
            align-items: center;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
        }

        .logo-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .logo-text {
            font-size: 24px;
            font-weight: 500;
            color: var(--dark-text);
        }

        .nav-links {
            list-style: none;
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .nav-links a {
            text-decoration: none;
            color: var(--dark-text);
            font-size: 14px;
            font-weight: 500;
            position: relative;
            transition: color 0.3s ease;
        }

        .nav-links a:hover {
            color: var(--accent-teal);
        }

        .nav-links a::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            height: 2px;
            width: 0;
            background-color: var(--accent-teal);
            transition: width 0.3s ease;
        }

        .nav-links a:hover::after {
            width: 100%;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Analytics Dashboard Section */
        .analytics-dashboard {
            padding: 120px 0 60px;
            background: linear-gradient(120deg, #ffffff 0%, rgba(245, 248, 250, 0.8) 100%);
            position: relative;
            overflow: hidden;
        }

        .analytics-dashboard::before {
            content: '';
            position: absolute;
            top: -300px;
            right: -300px;
            width: 600px;
            height: 600px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(52, 109, 241, 0.05) 0%, rgba(125, 76, 255, 0.05) 50%, transparent 70%);
            z-index: 0;
        }

        .analytics-dashboard::after {
            content: '';
            position: absolute;
            bottom: -200px;
            left: -200px;
            width: 500px;
            height: 500px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(34, 209, 198, 0.05) 0%, rgba(125, 76, 255, 0.05) 50%, transparent 70%);
            z-index: 0;
        }

        .dashboard-content {
            position: relative;
            z-index: 1;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.6s ease forwards 0.5s;
        }

        .dashboard-header {
            margin-bottom: 40px;
            text-align: center;
        }

        .dashboard-subtitle {
            font-size: 18px;
            line-height: 1.6;
            max-width: 700px;
            margin: 0 auto;
            color: rgba(42, 46, 61, 0.7);
        }

        .contract-details {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            padding: 28px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
            animation: fadeInUp 0.6s ease forwards 0.7s;
            opacity: 0;
            transform: translateY(20px);
            position: relative;
            overflow: hidden;
        }
        
        .contract-details::before, .segments-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient);
            border-radius: 4px 4px 0 0;
        }

        .contract-details-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }
        
        /* Segments Panel Styles */
        .segments-panel {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            padding: 28px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
            animation: fadeInUp 0.6s ease forwards 0.7s;
            opacity: 0;
            transform: translateY(20px);
            position: relative;
            overflow: hidden;
        }
        
        .segments-content {
            margin-top: 15px;
        }
        
        .segment-search {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .segment-search input {
            flex: 1;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        .segment-search input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(52, 109, 241, 0.2);
        }
        
        .segment-button {
            padding: 10px 16px;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .segment-button:hover {
            background: #2558d9;
        }
        
        .segment-button-outlined {
            background: transparent;
            color: var(--primary-blue);
            border: 1px solid var(--primary-blue);
        }
        
        .segment-button-outlined:hover {
            background: rgba(52, 109, 241, 0.1);
        }
        
        .active-segments {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .segment-tag {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(52, 109, 241, 0.1);
            color: var(--primary-blue);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
        }
        
        .segment-tag-remove {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(52, 109, 241, 0.2);
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .segment-tag-remove:hover {
            background: rgba(52, 109, 241, 0.3);
        }
        
        .segment-suggestions {
            margin-top: 10px;
            display: none;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-height: 200px;
            overflow-y: auto;
        }
        
        .segment-suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }
        
        .segment-suggestion-item:last-child {
            border-bottom: none;
        }
        
        .segment-suggestion-item:hover {
            background-color: rgba(52, 109, 241, 0.05);
        }
        
        .suggestion-title {
            padding: 8px 15px;
            font-size: 12px;
            font-weight: 600;
            color: rgba(42, 46, 61, 0.6);
            background-color: rgba(245, 248, 250, 0.7);
            border-bottom: 1px solid var(--border-color);
        }
        
        /* Event Type Filter styles */
        .filter-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .event-type-selector,
        .parameter-selector {
            flex: 1;
        }
        
        .filter-select {
            width: 100%;
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: white;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%232A2E3D' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
        }
        
        .filter-select:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(52, 109, 241, 0.2);
        }
        
        .filter-select:disabled {
            background-color: #f5f5f5;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .filter-select option {
            padding: 8px;
        }
        
        .event-tag {
            background-color: rgba(46, 204, 113, 0.1);
            color: #2ecc71;
            border: 1px solid rgba(46, 204, 113, 0.3);
        }
        
        .parameter-tag {
            background-color: rgba(155, 89, 182, 0.1);
            color: #9b59b6;
            border: 1px solid rgba(155, 89, 182, 0.3);
        }
        
        .event-type-indicator {
            font-weight: 600;
            opacity: 0.8;
            margin-right: 2px;
        }

        @media (max-width: 768px) {
            .contract-details-grid {
                grid-template-columns: 1fr;
            }
        }

        .detail-card {
            padding: 20px;
            background: white;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }
        
        .detail-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        }

        .detail-label {
            font-size: 14px;
            font-weight: 500;
            color: rgba(42, 46, 61, 0.6);
            margin-bottom: 10px;
            letter-spacing: 0.4px;
        }

        .detail-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--dark-text);
            word-break: break-all;
            padding: 4px 0;
            border-bottom: 2px solid rgba(52, 109, 241, 0.1);
        }

        .chart-card {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            padding: 24px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
            animation: fadeInUp 0.6s ease forwards 0.9s;
            opacity: 0;
            transform: translateY(20px);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(225, 228, 232, 0.5);
            padding-bottom: 15px;
        }

        .chart-title {
            font-weight: 600;
            font-size: 18px;
            color: var(--dark-text);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-controls {
            display: flex;
            gap: 10px;
        }

        .chart-button {
            background: rgba(52, 109, 241, 0.1);
            color: var(--primary-blue);
            border: none;
            border-radius: 5px;
            padding: 6px 12px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        .time-selector {
            display: flex;
            border-radius: 6px;
            background: var(--light-bg);
            overflow: hidden;
        }

        .time-option {
            padding: 6px 12px;
            font-size: 13px;
            color: rgba(42, 46, 61, 0.7);
            cursor: pointer;
        }

        .time-option.active {
            background: white;
            color: var(--primary-blue);
            font-weight: 500;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .chart-container {
            height: 400px;
            position: relative;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-top: 30px;
            animation: fadeInUp 0.6s ease forwards 1.1s;
            opacity: 0;
            transform: translateY(20px);
        }

        @media (max-width: 1024px) {
            .metrics-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .metrics-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .unique-addresses-card {
            background: linear-gradient(45deg, rgba(52, 109, 241, 0.05), rgba(125, 76, 255, 0.05));
            border-left: 3px solid var(--primary-blue);
        }

        .metric-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .metric-title {
            font-size: 14px;
            color: rgba(42, 46, 61, 0.7);
            margin-bottom: 10px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--dark-text);
            margin-bottom: 5px;
        }

        .metric-change {
            font-size: 13px;
            display: flex;
            align-items: center;
            color: rgba(42, 46, 61, 0.6);
        }

        /* Footer */
        .footer {
            background: white;
            border-top: 1px solid var(--border-color);
            padding: 60px 0 30px;
        }

        .footer-content {
            display: flex;
            gap: 60px;
        }

        .footer-column {
            flex: 1;
        }

        .footer-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--dark-text);
            margin-bottom: 16px;
        }

        .footer-link {
            display: block;
            color: rgba(42, 46, 61, 0.6);
            text-decoration: none;
            font-size: 14px;
            margin-bottom: 8px;
            transition: color 0.3s ease;
        }

        .footer-link:hover {
            color: var(--accent-teal);
        }

        .footer-bottom {
            margin-top: 40px;
            text-align: center;
            color: rgba(42, 46, 61, 0.6);
            font-size: 14px;
        }

        /* Animations */
        @keyframes pageLoadFade {
            to {
                opacity: 1;
            }
        }

        @keyframes headerLoadIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes refreshPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); color: #2ecc71; }
            100% { transform: scale(1); }
        }

        .refreshed {
            animation: refreshPulse 0.5s ease;
        }

        /* Hamburger Menu (Mobile) */
        .hamburger {
            display: none;
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
        }

        .hamburger-line {
            width: 24px;
            height: 2px;
            background: var(--dark-text);
            margin: 4px 0;
            transition: 0.3s;
        }

        @media (max-width: 768px) {
            .nav-links {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: white;
                flex-direction: column;
                padding: 20px 0;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            }

            .nav-links.active {
                display: flex;
            }

            .hamburger {
                display: block;
            }

            .chart-header {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <header class="header" id="header">
        <div class="container">
            <div class="header-content">
                <div class="logo-lockup">
                    <div class="logo-icon">
                        <img src="/images/logo.png" alt="logo" />
                    </div>
                    <div class="logo-text">decentrifi</div>
                </div>
                <button class="hamburger" id="hamburger">
                    <div class="hamburger-line"></div>
                    <div class="hamburger-line"></div>
                    <div class="hamburger-line"></div>
                </button>
                <nav>
                    <ul class="nav-links" id="nav-links">
                        <li><a href="../../../../../landing/index.html">Home</a></li>
                        <li><a href="#analytics">Analytics</a></li>
                        <li><a href="#docs">Docs</a></li>
                        <li><a href="#pricing">Pricing</a></li>
                        <li><a href="#login">Login</a></li>
                    </ul>
                </nav>
            </div>
        </div>
    </header>

    <section class="analytics-dashboard" id="analytics">
        <div class="container">
            <div class="dashboard-content">
                <div class="dashboard-header">
                    <h1>Smart Contract Gas Analytics</h1>
                    <p class="dashboard-subtitle">
                        Detailed gas usage metrics for your smart contract. Analyze trends, identify optimization opportunities, and reduce costs.
                    </p>
                </div>

                <div class="chart-card">
                    <div class="chart-header">
                        <div class="chart-title">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <circle cx="9" cy="7" r="4" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M23 21v-2a4 4 0 0 0-3-3.87" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M16 3.13a4 4 0 0 1 0 7.75" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            User Activity
                        </div>
                        <button id="refreshButton" class="chart-button" title="Refresh contract data">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M23 4v6h-6" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M1 20v-6h6" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Refresh
                        </button>
                    </div>
                    <div class="metrics-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="metric-card">
                            <div class="metric-title">Total Interactions</div>
                            <div class="metric-value" id="totalInteractions">0</div>
                            <div class="metric-change">Number of transactions in 24 hours</div>
                        </div>
                        <div class="metric-card unique-addresses-card">
                            <div class="metric-title">Active Users (24h)</div>
                            <div class="metric-value" id="uniqueAddressCount">0</div>
                            <div class="metric-change">Unique addresses in the last 24 hours</div>
                        </div>
                        <div class="metric-card" style="background: linear-gradient(45deg, rgba(46, 204, 113, 0.05), rgba(52, 152, 219, 0.05)); border-left: 3px solid #2ecc71;">
                            <div class="metric-title">Live Users <span class="live-indicator" style="display: inline-block; width: 8px; height: 8px; background-color: #2ecc71; border-radius: 50%; margin-left: 4px;"></span></div>
                            <div class="metric-value" id="liveUserCount">0</div>
                            <div class="metric-change">Active users in the last 30 minutes</div>
                        </div>
                    </div>
                </div>

                <div class="segments-panel">
                    <div class="chart-header">
                        <div class="chart-title">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M19 11h-6V5h6v6zm-6 2h6v6h-6v-6zm-2 6H5v-6h6v6zm0-14v6H5V5h6z" stroke="#346DF1" stroke-width="1.8"/>
                            </svg>
                            <span>Filters</span>
                        </div>
                        <button id="toggleFilters" class="chart-button">
                            <svg id="filterArrow" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(180deg); transition: transform 0.3s ease;">
                                <path d="M6 9l6 6 6-6" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <span id="filterToggleText">Show Filters</span>
                        </button>
                    </div>
                    <div class="active-segments" id="activeSegments" style="margin-top: 15px;">
                        <!-- Active segments will be displayed here -->
                    </div>

                    <div class="segments-content" id="filtersContent" style="display: none; transition: all 0.3s ease;">
                        <div class="filter-controls">
                            <div class="event-type-selector">
                                <select id="eventTypeSelect" class="filter-select">
                                    <option value="">Select Event Type</option>
                                    <!-- Event types will be loaded here -->
                                </select>
                            </div>
                            <div class="parameter-selector">
                                <select id="parameterSelect" class="filter-select" disabled>
                                    <option value="">Select Parameter</option>
                                    <!-- Parameters will be loaded here -->
                                </select>
                            </div>
                        </div>
                        <div class="segment-search">
                            <input type="text" id="segmentSearch" placeholder="Enter value (e.g., 0xabc...)" />
                            <button id="applySegment" class="segment-button">Apply Filter</button>
                            <button id="clearSegment" class="segment-button segment-button-outlined">Clear All</button>
                        </div>
                        <div class="segment-suggestions" id="segmentSuggestions">
                            <!-- Suggestions will be shown here -->
                        </div>
                    </div>
                </div>



                <div class="chart-card">
                    <div class="chart-header">
                        <div class="chart-title">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1z" stroke="#346DF1" stroke-width="2"/>
                                <path d="M8 10h8" stroke="#346DF1" stroke-width="2" stroke-linecap="round"/>
                                <path d="M8 14h4" stroke="#346DF1" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                            Events Per Hour by Type (T-24h to Now)
                        </div>
                        <div class="chart-controls">
                            <button class="chart-button">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M3 16.5L12 21L21 16.5" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    <path d="M3 12L12 16.5L21 12" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    <path d="M3 7.5L12 12L21 7.5L12 3L3 7.5Z" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                                Export
                            </button>
                            <div class="time-selector">
                                <div class="time-option active">Last 24 Hours</div>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="eventsChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-card">
                    <div class="chart-header">
                        <div class="chart-title">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M3 18H13" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M3 6H21" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M3 12H21" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Gas Usage (T-24h to Now)
                        </div>
                        <div class="chart-controls">
                            <button class="chart-button">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M3 16.5L12 21L21 16.5" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    <path d="M3 12L12 16.5L21 12" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    <path d="M3 7.5L12 12L21 7.5L12 3L3 7.5Z" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                                Export
                            </button>
                            <div class="time-selector">
                                <div class="time-option active">Last 24 Hours</div>
                            </div>
                        </div>
                    </div>
                    <div class="chart-container">
                        <canvas id="gasChart"></canvas>
                    </div>
                </div>

                <div class="chart-card">
                    <div class="chart-header">
                        <div class="chart-title">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M2 17L12 22L22 17" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M2 12L12 17L22 12" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            Gas Metrics (Last 24 Hours)
                        </div>
                    </div>
                    <div class="metrics-grid" style="grid-template-columns: repeat(3, 1fr);">
                        <div class="metric-card">
                            <div class="metric-title">Average Gas Used</div>
                            <div class="metric-value" id="avgGasUsed">0</div>
                            <div class="metric-change">Per transaction in the last 24 hours</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Max Gas Used</div>
                            <div class="metric-value" id="maxGasUsed">0</div>
                            <div class="metric-change">Highest gas consumption in 24 hours</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Total Gas (millions)</div>
                            <div class="metric-value" id="totalGasUsed">0</div>
                            <div class="metric-change">Total gas used in the last 24 hours</div>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
    </section>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-column">
                    <div class="logo-lockup" style="margin-bottom: 16px;">
                        <div class="logo-icon">
                            <img src="/images/logo.png" alt="logo" />
                        </div>
                        <div class="logo-text">decentrifi</div>
                    </div>
                    <p style="color: rgba(42, 46, 61, 0.6); font-size: 14px;">
                        Real-time on-chain insights<br>for EVM contracts
                    </p>
                </div>
                <div class="footer-column">
                    <h4 class="footer-title">Product</h4>
                    <a href="#" class="footer-link">Features</a>
                    <a href="#" class="footer-link">API Documentation</a>
                    <a href="#" class="footer-link">Roadmap</a>
                    <a href="#" class="footer-link">Status</a>
                </div>
                <div class="footer-column">
                    <h4 class="footer-title">Resources</h4>
                    <a href="#" class="footer-link">Documentation</a>
                    <a href="#" class="footer-link">Blog</a>
                    <a href="#" class="footer-link">Community</a>
                    <a href="#" class="footer-link">Support</a>
                </div>
                <div class="footer-column">
                    <h4 class="footer-title">Social</h4>
                    <a href="#" class="footer-link">Twitter</a>
                    <a href="#" class="footer-link">Discord</a>
                    <a href="#" class="footer-link">GitHub</a>
                    <a href="#" class="footer-link">LinkedIn</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>Â© 2025 Decentrifi. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script>
        // Header scroll effect
        window.addEventListener('scroll', function() {
            const header = document.getElementById('header');
            if (window.scrollY > 50) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
        });

        // Mobile menu toggle
        const hamburger = document.getElementById('hamburger');
        const navLinks = document.getElementById('nav-links');

        hamburger.addEventListener('click', function() {
            navLinks.classList.toggle('active');
        });
        
        // Filter toggle functionality
        const toggleFiltersBtn = document.getElementById('toggleFilters');
        const filtersContent = document.getElementById('filtersContent');
        const filterArrow = document.getElementById('filterArrow');
        const filterToggleText = document.getElementById('filterToggleText');
        
        toggleFiltersBtn.addEventListener('click', function() {
            // Toggle display of filters content
            const isVisible = filtersContent.style.display !== 'none';
            
            if (isVisible) {
                filtersContent.style.display = 'none';
                filterArrow.style.transform = 'rotate(180deg)';
                filterToggleText.textContent = 'Show Filters';
            } else {
                filtersContent.style.display = 'block';
                filterArrow.style.transform = 'rotate(0deg)';
                filterToggleText.textContent = 'Hide Filters';
            }
        });

        // Store active segments globally
        const activeSegments = new Set();

        // Initialize the segments panel
        const segmentSearch = document.getElementById('segmentSearch');
        const segmentSuggestions = document.getElementById('segmentSuggestions');
        const activeSegmentsContainer = document.getElementById('activeSegments');
        const applySegmentBtn = document.getElementById('applySegment');
        const clearSegmentBtn = document.getElementById('clearSegment');

        // Function to fetch real gas usage data from the API
        async function fetchDailyGasUsageData(network, contract, filters = []) {
            try {
                let url = `/data/${network}/${contract}/gas-used/daily`;
                
                // Add filters as query parameters if they exist
                if (filters.length > 0) {
                    const filterParams = filters.map(f => `filter=${encodeURIComponent(f.key + ':' + f.value)}`).join('&');
                    url += `?${filterParams}`;
                }
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("Error fetching gas usage data:", error);
                return null;
            }
        }

        // Function to extract network and contract address from URL
        function getNetworkAndContract() {
            const path = window.location.pathname;
            const pathParts = path.split('/').filter(part => part.length > 0);
            
            if (pathParts.length >= 2) {
                return {
                    network: pathParts[0],
                    contract: pathParts[1]
                };
            }
            
            // Default values if not found in URL
            return {
                network: 'ethereum',
                contract: '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D'
            };
        }
        
        // Function to fetch unique addresses for a contract on a network
        async function fetchUniqueAddressesCount(network, contract) {
            try {
                const url = `/data/${network}/${contract}/active-users/1d`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("Error fetching unique addresses count:", error);
                return null;
            }
        }

        // Function to fetch active users in the last 30 minutes
        async function fetchLiveUsersCount(network, contract) {
            try {
                const url = `/data/${network}/${contract}/active-users/30min`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("Error fetching live users count:", error);
                return null;
            }
        }

        // Process real data for daily chart
        function processDailyGasData(apiData) {
            // Generate labels for the last 24 hours (T-24h to now) in local browser time
            const now = new Date();
            const hourLabels = Array.from({length: 24}, (_, i) => {
                const hourAgo = new Date(now);
                hourAgo.setHours(now.getHours() - (23 - i)); // 23 hours ago to now
                return `${hourAgo.getHours()}:00`;
            });
            
            if (!apiData || !apiData.dataPoints) {
                return {
                    labels: hourLabels,
                    datasets: [
                        {
                            label: 'Gas Used',
                            data: Array(24).fill(0), // Empty data if API fails
                            borderColor: '#346DF1',
                            backgroundColor: 'rgba(52, 109, 241, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }
                    ]
                };
            }

            // Extract data points from API response
            const dataPoints = apiData.dataPoints;
            
            // Create an array of 24 elements with zeros
            const gasUsedValues = Array(24).fill(0);
            
            // Get current time for comparing timestamps
            const currentTime = now.getTime();
            
            // Create an array of all hour slots from 24 hours ago to now, in UTC
            const hourSlots = [];
            const nowUtc = new Date(Date.now());
            
            for (let i = 23; i >= 0; i--) {
                const slotTime = new Date(nowUtc);
                slotTime.setHours(nowUtc.getHours() - i);
                slotTime.setMinutes(0, 0, 0);
                hourSlots.push(slotTime);
            }
            
            // Map the data points to the appropriate position in our timeline
            dataPoints.forEach(point => {
                // Parse the timestamp from the backend (already in ISO-8601 format)
                // Note: Backend sends UTC timestamps
                const date = new Date(point.timestamp);

                // Find which hour slot this timestamp belongs to
                for (let i = 0; i < hourSlots.length; i++) {
                    const slot = hourSlots[i];
                    // If timestamps are in the same hour
                    if (slot.getUTCFullYear() === date.getUTCFullYear() &&
                        slot.getUTCMonth() === date.getUTCMonth() &&
                        slot.getUTCDate() === date.getUTCDate() &&
                        slot.getUTCHours() === date.getUTCHours()) {
                        // Assign gas used value to correct index
                        gasUsedValues[i] = point.gasUsed;
                        break;
                    }
                }
            });
            
            return {
                labels: hourLabels,
                datasets: [
                    {
                        label: 'Gas Used',
                        data: gasUsedValues,
                        borderColor: '#346DF1',
                        backgroundColor: 'rgba(52, 109, 241, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true
                    }
                ]
            };
        }

        // Initialize with empty data for daily view (will be replaced with real data)
        // Generate labels for the last 24 hours
        const gasChartNow = new Date();
        const gasChartLabels = Array.from({length: 24}, (_, i) => {
            const hourAgo = new Date(gasChartNow);
            hourAgo.setHours(gasChartNow.getHours() - (23 - i)); // 23 hours ago to now
            return `${hourAgo.getHours()}:00`;
        });
        
        let chartData = {
            labels: gasChartLabels,
            datasets: [
                {
                    label: 'Gas Used',
                    data: Array(24).fill(0), // Start with zeros
                    borderColor: '#346DF1',
                    backgroundColor: 'rgba(52, 109, 241, 0.1)',
                    borderWidth: 2,
                    tension: 0.4,
                    fill: true
                }
            ]
        };

        // Initialize chart options
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                }
            },
            scales: {
                y: {
                    beginAtZero: false,
                    title: {
                        display: true,
                        text: 'Gas Used'
                    },
                    grid: {
                        color: 'rgba(225, 228, 232, 0.3)',
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Last 24 Hours'
                    },
                    grid: {
                        color: 'rgba(225, 228, 232, 0.3)',
                    }
                }
            },
            interaction: {
                mode: 'nearest',
                axis: 'x',
                intersect: false
            },
            animations: {
                tension: {
                    duration: 1000,
                    easing: 'linear'
                }
            }
        };

        // Create the chart with initial data
        const ctx = document.getElementById('gasChart').getContext('2d');
        let gasChart = new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: chartOptions
        });

        // Update metrics cards with real data
        function updateMetricsCards(data) {
            if (!data || !data.dataPoints || data.dataPoints.length === 0) return;
            
            // Calculate average gas used
            const totalGasUsed = data.dataPoints.reduce((sum, point) => sum + point.gasUsed, 0);
            const avgGasUsed = Math.round(totalGasUsed / data.dataPoints.length);
            
            // Find max gas used
            const maxGasUsed = Math.max(...data.dataPoints.map(point => point.gasUsed));
            
            // Calculate total gas used
            const totalGas = data.dataPoints.reduce((sum, point) => sum + point.gasUsed, 0);
            
            // Count transactions
            const txCount = data.txCount;
            
            // Update the metrics by ID instead of relying on element order
            const avgGasUsedElement = document.getElementById('avgGasUsed');
            const maxGasUsedElement = document.getElementById('maxGasUsed');
            const totalGasElement = document.getElementById('totalGasUsed');
            const totalInteractionsElement = document.getElementById('totalInteractions');
            
            // Update gas metrics
            if (avgGasUsedElement) {
                avgGasUsedElement.textContent = avgGasUsed.toLocaleString();
            }
            
            if (maxGasUsedElement) {
                maxGasUsedElement.textContent = maxGasUsed.toLocaleString();
            }
            
            if (totalGasElement) {
                totalGasElement.textContent = (totalGas / 1000000).toFixed(2).toLocaleString();
            }
            
            // Update interaction metrics
            if (totalInteractionsElement) {
                totalInteractionsElement.textContent = txCount.toLocaleString();
            }
        }
        
        // Function to fetch events data from the API with optional filters
        async function fetchEventsData(network, contract, filters = []) {
            try {
                let url = `/data/${network}/${contract}/events/daily`;
                
                // Add filters as query parameters if they exist
                if (filters.length > 0) {
                    const filterParams = filters.map(f => `filter=${encodeURIComponent(f.key + ':' + f.value)}`).join('&');
                    url += `?${filterParams}`;
                }
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("Error fetching events data:", error);
                return null;
            }
        }
        
        // Process events data for stacked bar chart by hour and type
        function processEventsData(apiData) {
            // Create hour labels for the last 24 hours (from now backwards)
            const now = new Date();
            const hourLabels = Array.from({length: 24}, (_, i) => {
                const hourAgo = new Date(now);
                hourAgo.setHours(now.getHours() - (23 - i)); // 23 hours ago to now
                return `${hourAgo.getHours()}:00`;
            });
            
            // Check if we have valid data from the API
            if (!apiData || !apiData.eventTypes || apiData.eventTypes.length === 0) {
                return {
                    labels: hourLabels,
                    datasets: [
                        {
                            label: 'No Events',
                            data: Array(24).fill(0),
                            backgroundColor: 'rgba(52, 109, 241, 0.7)',
                            borderColor: '#346DF1',
                            borderWidth: 1
                        }
                    ]
                };
            }
            
            // Generate a color palette for our event types
            const colorPalette = [
                'rgba(52, 109, 241, 0.8)',    // Blue
                'rgba(34, 209, 198, 0.8)',    // Teal
                'rgba(230, 100, 80, 0.8)',    // Red/Orange
                'rgba(143, 97, 227, 0.8)',    // Purple
                'rgba(241, 196, 15, 0.8)',    // Yellow
                'rgba(46, 204, 113, 0.8)',    // Green
                'rgba(231, 76, 60, 0.8)',     // Red
                'rgba(155, 89, 182, 0.8)',    // Violet
                'rgba(52, 152, 219, 0.8)',    // Light Blue
                'rgba(243, 156, 18, 0.8)'     // Orange
            ];
            
            // If we have more event types than colors, we'll cycle through them
            const getColor = (index) => {
                return colorPalette[index % colorPalette.length];
            };
            
            // Create a dataset for each event type from the backend data
            const datasets = apiData.eventTypes.map((eventType, index) => {
                // Convert the hourly counts to an array of 24 values (from T-24h to now)
                const hourlyData = Array(24).fill(0);
                
                // Get the current date for comparison
                const now = new Date();
                
                // Fill in the data from the API, mapping the timestamps to our T-24h to now timeline
                eventType.hourlyCounts.forEach(hourCount => {
                    // New structure uses timestamp instead of hour
                    if (hourCount.timestamp) {
                        // Create a date from the timestamp
                        const eventTime = new Date(hourCount.timestamp);
                        
                        // Calculate hours from now
                        const hourDiff = Math.floor((now - eventTime) / (60 * 60 * 1000));
                        
                        // Only include data from the last 24 hours
                        if (hourDiff >= 0 && hourDiff < 24) {
                            const timelineIndex = 23 - hourDiff;
                            hourlyData[timelineIndex] = hourCount.count;
                        }
                    }
                });
                
                return {
                    label: eventType.eventName,
                    data: hourlyData,
                    backgroundColor: getColor(index),
                    borderColor: getColor(index).replace('0.8', '1.0'),
                    borderWidth: 1
                };
            });
            
            return {
                labels: hourLabels,
                datasets: datasets
            };
        }
        
        // Initialize events chart
        const eventsCtx = document.getElementById('eventsChart').getContext('2d');
        // Generate labels for the last 24 hours
        const currentTime = new Date();
        const last24HoursLabels = Array.from({length: 24}, (_, i) => {
            const hourAgo = new Date(currentTime);
            hourAgo.setHours(currentTime.getHours() - (23 - i)); // 23 hours ago to now
            return `${hourAgo.getHours()}:00`;
        });
        
        let eventsChartData = {
            labels: last24HoursLabels,
            datasets: [
                {
                    label: 'Loading...',
                    data: Array(24).fill(0),
                    backgroundColor: 'rgba(52, 109, 241, 0.7)',
                    borderColor: '#346DF1',
                    borderWidth: 1
                }
            ]
        };
        
        const eventsChartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        font: {
                            size: 12
                        }
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            return `${context.dataset.label}: ${context.parsed.y}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    stacked: true,
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Number of Events'
                    },
                    ticks: {
                        precision: 0
                    },
                    grid: {
                        color: 'rgba(225, 228, 232, 0.3)',
                    }
                },
                x: {
                    stacked: true,
                    title: {
                        display: true,
                        text: 'Last 24 Hours'
                    },
                    grid: {
                        color: 'rgba(225, 228, 232, 0.3)',
                    }
                }
            }
        };
        
        let eventsChart = new Chart(eventsCtx, {
            type: 'bar',
            data: eventsChartData,
            options: eventsChartOptions
        });
        
        // Function to parse a segment string (e.g., "sender=0xabc...")
        function parseSegment(segmentText) {
            const parts = segmentText.split('=');
            if (parts.length !== 2 || !parts[0].trim() || !parts[1].trim()) {
                return null;
            }
            
            return {
                key: parts[0].trim(),
                value: parts[1].trim()
            };
        }
        
        // Function to add a segment tag to the UI
        function addSegmentTag(segment, eventType = null) {
            const segmentTag = document.createElement('div');
            
            // Apply different styles based on if we have event context
            if (eventType) {
                segmentTag.className = 'segment-tag parameter-tag';
            } else {
                segmentTag.className = 'segment-tag';
            }
            
            segmentTag.setAttribute('data-key', segment.key);
            segmentTag.setAttribute('data-value', segment.value);
            
            // If we have event type, display it as part of the tag
            if (eventType) {
                segmentTag.innerHTML = `
                    <span class="event-type-indicator">${eventType}:</span> ${segment.key}=${segment.value}
                    <span class="segment-tag-remove">Ã</span>
                `;
            } else {
                segmentTag.innerHTML = `
                    ${segment.key}=${segment.value}
                    <span class="segment-tag-remove">Ã</span>
                `;
            }
            
            // Add click handler for removal
            segmentTag.querySelector('.segment-tag-remove').addEventListener('click', function() {
                segmentTag.remove();
                
                // Remove from active segments
                const segmentStr = `${segment.key}:${segment.value}`;
                activeSegments.delete(segmentStr);
                
                // Reload data with updated filters
                reloadChartsWithFilters();
            });
            
            activeSegmentsContainer.appendChild(segmentTag);
            
            // Add to active segments set
            const segmentStr = `${segment.key}:${segment.value}`;
            activeSegments.add(segmentStr);
        }
        
        // Generate filter objects from activeSegments set
        function getActiveFilters() {
            const filters = [];
            activeSegments.forEach(segmentStr => {
                const [key, value] = segmentStr.split(':');
                filters.push({ key, value });
            });
            return filters;
        }
        
        // Function to reload all charts with current filters
        async function reloadChartsWithFilters() {
            const filters = getActiveFilters();
            const { network, contract } = getNetworkAndContract();
            
            // Fetch all data in parallel with filters
            const [gasData, eventsData, uniqueAddressesData] = await Promise.all([
                fetchDailyGasUsageData(network, contract, filters),
                fetchEventsData(network, contract, filters),
                fetchUniqueAddressesCount(network, contract) // Note: unique addresses endpoint doesn't support filters yet
            ]);
            
            // Update gas usage chart
            if (gasData) {
                const processedGasData = processDailyGasData(gasData);
                gasChart.data.labels = processedGasData.labels;
                gasChart.data.datasets = processedGasData.datasets;
                gasChart.update();
                
                // Update metrics cards with real data
                updateMetricsCards(gasData);
            }
            
            // Update events chart
            if (eventsData) {
                const processedEventsData = processEventsData(eventsData);
                eventsChart.data.labels = processedEventsData.labels;
                eventsChart.data.datasets = processedEventsData.datasets;
                eventsChart.update();
                
                // Update segment suggestions from event data
                updateSegmentSuggestions(eventsData);
            }
            
            // Update unique addresses count
            if (uniqueAddressesData) {
                const uniqueAddressElement = document.getElementById('uniqueAddressCount');
                if (uniqueAddressElement) {
                    uniqueAddressElement.textContent = uniqueAddressesData.uniqueAddressCount.toLocaleString();
                }
            }
        }
        
        // Function to fetch decoded event keys from the API
        async function fetchDecodedEventKeys(network, contract) {
            try {
                const url = `/data/${network}/${contract}/events/decoded-keys`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error("Error fetching decoded event keys:", error);
                return null;
            }
        }
        
        // Global variable to store event keys by type
        let eventKeysData = null;
        
        // Function to update event type dropdown
        function updateEventTypeSelector(decodedKeys) {
            if (!decodedKeys || !decodedKeys.eventKeys) return;
            
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            // Clear current options except the first one
            while (eventTypeSelect.options.length > 1) {
                eventTypeSelect.remove(1);
            }
            
            // Add event types from the API data
            const eventTypes = Object.keys(decodedKeys.eventKeys);
            eventTypes.forEach(eventType => {
                const option = document.createElement('option');
                option.value = eventType;
                option.textContent = eventType;
                eventTypeSelect.appendChild(option);
            });
            
            // Enable the select if we have options
            eventTypeSelect.disabled = eventTypes.length === 0;
            
            // Store the data globally for later use
            eventKeysData = decodedKeys;
        }
        
        // Function to update parameter dropdown based on selected event type
        function updateParameterSelector(eventType) {
            const parameterSelect = document.getElementById('parameterSelect');
            
            // Clear current options except the first one
            while (parameterSelect.options.length > 1) {
                parameterSelect.remove(1);
            }
            
            if (!eventType || !eventKeysData || !eventKeysData.eventKeys[eventType]) {
                parameterSelect.disabled = true;
                return;
            }
            
            // Add parameters from the selected event type
            const parameters = eventKeysData.eventKeys[eventType];
            parameters.forEach(param => {
                const option = document.createElement('option');
                option.value = param;
                option.textContent = param;
                parameterSelect.appendChild(option);
            });
            
            // Enable the select if we have options
            parameterSelect.disabled = parameters.length === 0;
            
            // Update placeholder in search input
            if (parameters.length > 0) {
                segmentSearch.placeholder = `Enter value for ${parameters[0]}`;
            } else {
                segmentSearch.placeholder = "Enter value";
            }
        }
        
        // Function to update segment suggestions based on event data
        function updateSegmentSuggestions(eventsData) {
            // Clear existing suggestions
            segmentSuggestions.innerHTML = '';
            
            if (!eventKeysData || !eventKeysData.eventKeys) {
                // Fallback to generic suggestions
                const suggestedFields = [
                    'sender', 'recipient', 'amount', 'tokenId', 'aggregatorId', 
                    'price', 'operator', 'owner', 'spender', 'value'
                ];
                
                // Add title
                const suggestionTitle = document.createElement('div');
                suggestionTitle.className = 'suggestion-title';
                suggestionTitle.textContent = 'Common fields:';
                segmentSuggestions.appendChild(suggestionTitle);
                
                // Add suggestion items
                suggestedFields.forEach(field => {
                    const item = document.createElement('div');
                    item.className = 'segment-suggestion-item';
                    item.textContent = field;
                    
                    item.addEventListener('click', function() {
                        segmentSearch.value = field + '=';
                        segmentSearch.focus();
                        // Position cursor after the "="
                        const pos = segmentSearch.value.length;
                        segmentSearch.setSelectionRange(pos, pos);
                    });
                    
                    segmentSuggestions.appendChild(item);
                });
                return;
            }
            
            // If we have event data, show event types and their parameters
            const eventTypes = Object.keys(eventKeysData.eventKeys);
            
            // Only show suggestions if we have actual parameters
            if (eventTypes.length > 0) {
                // Add title
                const suggestionTitle = document.createElement('div');
                suggestionTitle.className = 'suggestion-title';
                suggestionTitle.textContent = 'Event Parameters:';
                segmentSuggestions.appendChild(suggestionTitle);
                
                // Add suggestion items grouped by event type
                eventTypes.forEach(eventType => {
                    const params = eventKeysData.eventKeys[eventType];
                    if (params && params.length > 0) {
                        // Add event type header
                        const eventHeader = document.createElement('div');
                        eventHeader.className = 'suggestion-title event-type-header';
                        eventHeader.textContent = eventType;
                        segmentSuggestions.appendChild(eventHeader);
                        
                        // Add parameter items
                        params.forEach(param => {
                            const item = document.createElement('div');
                            item.className = 'segment-suggestion-item';
                            item.textContent = `${param}`;
                            
                            item.addEventListener('click', function() {
                                // Set the event type in the dropdown
                                const eventTypeSelect = document.getElementById('eventTypeSelect');
                                eventTypeSelect.value = eventType;
                                
                                // Update parameter dropdown
                                updateParameterSelector(eventType);
                                
                                // Set the selected parameter
                                const parameterSelect = document.getElementById('parameterSelect');
                                parameterSelect.value = param;
                                
                                // Focus on the search input
                                segmentSearch.placeholder = `Enter value for ${param}`;
                                segmentSearch.focus();
                                
                                // Hide suggestions
                                segmentSuggestions.style.display = 'none';
                            });
                            
                            segmentSuggestions.appendChild(item);
                        });
                    }
                });
            }
        }
        
        // Event handler for event type selector
        document.getElementById('eventTypeSelect').addEventListener('change', function() {
            const selectedEventType = this.value;
            updateParameterSelector(selectedEventType);
        });
        
        // Event handler for parameter selector
        document.getElementById('parameterSelect').addEventListener('change', function() {
            const selectedParam = this.value;
            if (selectedParam) {
                segmentSearch.placeholder = `Enter value for ${selectedParam}`;
                segmentSearch.focus();
            }
        });
        
        // Event handler for apply button
        applySegmentBtn.addEventListener('click', function() {
            const eventTypeSelect = document.getElementById('eventTypeSelect');
            const parameterSelect = document.getElementById('parameterSelect');
            const segmentValue = segmentSearch.value.trim();
            
            // Get the selected event type and parameter
            const eventType = eventTypeSelect.value;
            const parameter = parameterSelect.value;
            
            // If we have the dropdowns filled, use those
            if (eventType && parameter) {
                if (!segmentValue) {
                    alert('Please enter a value for the selected parameter');
                    return;
                }
                
                // Create segment from dropdown selections
                const segment = {
                    key: parameter,
                    value: segmentValue
                };
                
                // Check if this segment already exists
                const segmentStr = `${segment.key}:${segment.value}`;
                if (activeSegments.has(segmentStr)) {
                    alert('This filter is already applied');
                    return;
                }
                
                // Add the segment tag with event context
                addSegmentTag(segment, eventType);
                segmentSearch.value = '';
                
                // Reload data with the new filter
                reloadChartsWithFilters();
            } else {
                // Legacy format (text input only)
                const segmentText = segmentSearch.value.trim();
                if (!segmentText) return;
                
                const segment = parseSegment(segmentText);
                if (!segment) {
                    alert('Please select an event type and parameter, or enter a valid filter in the format "field=value"');
                    return;
                }
                
                // Check if this segment already exists
                const segmentStr = `${segment.key}:${segment.value}`;
                if (activeSegments.has(segmentStr)) {
                    alert('This filter is already applied');
                    return;
                }
                
                // Add the segment tag and update the data
                addSegmentTag(segment);
                segmentSearch.value = '';
                
                // Reload data with the new filter
                reloadChartsWithFilters();
            }
        });
        
        // Event handler for clear button
        clearSegmentBtn.addEventListener('click', function() {
            // Clear all segment tags
            activeSegmentsContainer.innerHTML = '';
            activeSegments.clear();
            
            // Reload data without filters
            reloadChartsWithFilters();
        });
        
        // Event listener for Enter key in the search input
        segmentSearch.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                applySegmentBtn.click();
            }
        });
        
        // Function to show segment suggestions
        segmentSearch.addEventListener('focus', function() {
            segmentSuggestions.style.display = 'block';
        });
        
        // Function to hide segment suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!segmentSearch.contains(e.target) && !segmentSuggestions.contains(e.target)) {
                segmentSuggestions.style.display = 'none';
            }
        });
        
        // Function to filter suggestions as user types
        segmentSearch.addEventListener('input', function() {
            const searchText = segmentSearch.value.trim().toLowerCase();
            
            // If search includes '=', don't filter suggestions
            if (searchText.includes('=')) {
                return;
            }
            
            // Show only matching suggestions
            const suggestions = segmentSuggestions.querySelectorAll('.segment-suggestion-item');
            suggestions.forEach(item => {
                if (searchText === '' || item.textContent.toLowerCase().includes(searchText)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        });
        
        // Function to update the live users count with auto-refresh
        async function updateLiveUsersCount() {
            const { network, contract } = getNetworkAndContract();

            try {
                const liveUsersData = await fetchLiveUsersCount(network, contract);

                if (liveUsersData && liveUsersData.activeUsers !== undefined) {
                    const liveUserCountElement = document.getElementById('liveUserCount');
                    if (liveUserCountElement) {
                        liveUserCountElement.textContent = liveUsersData.activeUsers.toLocaleString();

                        // Add a subtle animation to indicate refresh
                        liveUserCountElement.classList.add('refreshed');
                        setTimeout(() => {
                            liveUserCountElement.classList.remove('refreshed');
                        }, 500);
                    }
                }
            } catch (error) {
                console.error("Error updating live users count:", error);
            }
        }

        // Fetch and update all charts and metrics on page load
        async function initializeRealData() {
            const { network, contract } = getNetworkAndContract();

            // Contract details section has been removed

            // Fetch all data in parallel
            const [gasData, eventsData, decodedKeys, uniqueAddressesData, liveUsersData] = await Promise.all([
                fetchDailyGasUsageData(network, contract),
                fetchEventsData(network, contract),
                fetchDecodedEventKeys(network, contract),
                fetchUniqueAddressesCount(network, contract),
                fetchLiveUsersCount(network, contract)
            ]);

            // Update gas usage chart
            if (gasData) {
                const processedGasData = processDailyGasData(gasData);
                gasChart.data.labels = processedGasData.labels;
                gasChart.data.datasets = processedGasData.datasets;
                gasChart.update();

                // Update metrics cards with real data
                updateMetricsCards(gasData);
            }

            // Update events chart
            if (eventsData) {
                const processedEventsData = processEventsData(eventsData);
                eventsChart.data.labels = processedEventsData.labels;
                eventsChart.data.datasets = processedEventsData.datasets;
                eventsChart.update();
            }

            // Update unique addresses count if available
            if (uniqueAddressesData) {
                const uniqueAddressElement = document.getElementById('uniqueAddressCount');
                if (uniqueAddressElement) {
                    uniqueAddressElement.textContent = uniqueAddressesData.uniqueAddressCount.toLocaleString();
                }
            }

            // Update live users count if available
            if (liveUsersData) {
                const liveUserCountElement = document.getElementById('liveUserCount');
                if (liveUserCountElement) {
                    liveUserCountElement.textContent = liveUsersData.activeUsers.toLocaleString();
                }
            }

            // Update event type selector and parameter dropdown with decoded keys
            if (decodedKeys) {
                updateEventTypeSelector(decodedKeys);
                // Initialize segment suggestions with the decoded keys
                updateSegmentSuggestions(eventsData);
            } else {
                // Fallback to basic suggestions if we couldn't fetch decoded keys
                updateSegmentSuggestions(eventsData);
            }

            // Set up auto-refresh for live users count every 5 seconds
            setInterval(updateLiveUsersCount, 5000);
        }

        // Initialize real data on page load
        initializeRealData();

        // Add refresh button functionality
        document.getElementById('refreshButton').addEventListener('click', async function() {
            try {
                // Get network and contract from URL
                const { network, contract } = getNetworkAndContract();

                // Change button appearance to indicate loading
                const refreshButton = document.getElementById('refreshButton');
                const originalContent = refreshButton.innerHTML;
                refreshButton.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="rotating">
                        <path d="M23 4v6h-6" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M1 20v-6h6" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" stroke="#346DF1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    Refreshing...
                `;
                refreshButton.disabled = true;

                // Add rotating animation to the icon
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes rotate {
                        from { transform: rotate(0deg); }
                        to { transform: rotate(360deg); }
                    }
                    .rotating {
                        animation: rotate 1.5s linear infinite;
                    }
                `;
                document.head.appendChild(style);

                // Send request to trigger data ingestion
                const response = await fetch(`/${network}/${contract}/ingest`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log("Ingestion job launched:", result);

                // Show a success message
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background-color: rgba(46, 204, 113, 0.9);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-weight: 500;
                    z-index: 1000;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    transition: all 0.3s ease;
                `;
                toast.textContent = 'Refresh job started successfully! Data will update soon.';
                document.body.appendChild(toast);

                // Remove toast after 5 seconds
                setTimeout(() => {
                    toast.style.opacity = '0';
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }, 5000);

                // Reset button after 2 seconds to indicate completion
                setTimeout(() => {
                    refreshButton.innerHTML = originalContent;
                    refreshButton.disabled = false;

                    // Reload the data to reflect any immediate changes
                    reloadChartsWithFilters();
                }, 2000);

            } catch (error) {
                console.error("Error refreshing data:", error);

                // Show error message
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background-color: rgba(231, 76, 60, 0.9);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-weight: 500;
                    z-index: 1000;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                `;
                toast.textContent = 'Failed to refresh data. Please try again.';
                document.body.appendChild(toast);

                // Remove toast after 5 seconds
                setTimeout(() => {
                    toast.style.opacity = '0';
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }, 5000);

                // Reset button
                document.getElementById('refreshButton').innerHTML = originalContent;
                document.getElementById('refreshButton').disabled = false;
            }
        });
    </script>
</body>
</html>